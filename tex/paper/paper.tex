%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Packages are included below, these are akin to libraries in other programming languages. As far as I can tell, there is no reason to reduce the number of packages included in a document. It might compile faster, but overleaf compiles fast so this should not be an issue.
\documentclass[12pt,twoside]{report} %tells the compiler that this is a 'report' style document, and the main font size.
\usepackage{setspace} %allows the use of '\doublespace' to set line spacing
\usepackage[utf8]{inputenc} %inclusion of this is optional, overleaf includes it in its compiler so it is not necessary, it may be necessary for other compilers.
\usepackage[english]{babel} %this does a few things eg allowing dates to be made by the compiler. probably best not to get rid of it
\usepackage{wrapfig} %if it is desirable to wrap text (see https://www.overleaf.com/learn/latex/Wrapping_text_around_figures).
\usepackage{graphicx} %this allows graphics to be put in easily
\usepackage{float}%this allows you to put them in good places
\usepackage[version=4]{mhchem} %this is good for chemical reactions
\usepackage{amsmath} %maths package
\usepackage{amssymb} %symbol package
\usepackage{textcomp,gensymb} %more symbols (eg \degree)
\usepackage{appendix} %self explanatory
\usepackage{colortbl} %good for colouring in cells on a table
\usepackage{rotating} %allows you to rotate graphics
\usepackage{bm} %helps bold things
\usepackage{multirow} %for tables
\usepackage{longtable} %for long tables
\usepackage{booktabs} %more tables
\usepackage{pdfpages} %allows PDFs to be included in document (good if you want to include a pdf in an appendix eg)
\usepackage{caption} %allows captions for graphics
\usepackage[nottoc]{tocbibind} %adds the bibliography to the table of contents
\usepackage{subcaption} %allows subcaption for multiple images in one graphic
\usepackage{enumitem} %for the bulleted lists

\PassOptionsToPackage{hyphens}{url}
\usepackage{hyperref} %this is great for putting hyperreferences in the document.
\usepackage[table]{xcolor} %more colouring of tables
\definecolor{Gray}{gray}{0.9} %this defines a colour to be used and gives it a name. This is a colour called 'Gray' it is 'gray' with transparency 0.9
\input{rust.tex}  %I used this to format rust code well in my report. I'm sure there are other packages/methods for other languages.
\hypersetup{colorlinks=false} %this stops links being colourful, which makes a report look less professional I believe.


\usepackage[letterpaper, top=1in, bottom = 1in, right = 1in, left=1in]{geometry} %this describes the layout of the document and the margins etc.
\doublespacing %self explanatory
\usepackage{afterpage} %for blank pages

\title{Implementing a Unix Shell}
\author{Shreyas Mayya}
\date{April 29, 2022}

\begin{document} % you have to do this to start the document

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%For a long report such as a thesis, I would recommend thinking like programming, that is, have a short 'main' and long programs (or chapters in this case) this allows you to access each chapter easily and see the layout of the document easily.
%
%using \input{} basically puts the code specified in the argument (between the braces) into the body of the code in main
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The entire thesis is generated by the commands below, referencing the other files in this directory.

\sloppy

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Preamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\begin{titlepage}
		\begin{center}
			\vspace*{1.75in}
			\Huge
			\textbf{Implementing a Unix Shell}
			\vspace{0.5in}

			\LARGE
			\textbf{Shreyas Mayya}
			\vspace{0.5in}

			\Large
			Computer Systems Lab\\
			Thomas Jefferson High School for Science and Technology\\
			Alexandria, VA\\
			April 29, 2022
		\end{center}
	\end{titlepage}

	\pagenumbering{roman} %Roman numbering is recommended until the body

	\newcommand\blankpage{%
		\null
		\thispagestyle{empty}%
		\addtocounter{page}{-1}%
		\newpage}

	\afterpage{\blankpage{}}

% 	\chapter*{Acknowledgments}
% 	I would like to thank:
	
% 	\afterpage{\null\newpage}

	\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\chapter*{Abstract}
	A command-line shell is a program that takes a command as input, executes it, and returns the command’s output. This paper discusses the process of implementing a shell for Unix systems. Using the Rust programming language, I programmed a shell from scratch with the goal of making it work similarly to the Bourne-again shell \verb|bash|. Ultimately, while the new shell does not support many advanced features or syntax, it is able to execute basic, non-interactive commands from user input or a script. In addition, it can save command history to a file, select and execute previously-run commands, and handle some keyboard shortcuts.

	\afterpage{\blankpage{}}

	\chapter{Introduction}
	
	\pagenumbering{arabic} %back to Arabic numbering for the rest

    A command-line shell is one of the most important components of a computer. It provides an interface for a user to execute typed commands, along with syntax that enables advanced logic and offers the ability to handle command outputs. Over the years, shells have become increasingly more powerful and feature-rich. How exactly do they work? This project aims to find that out by building a shell for Unix systems from scratch.
    
    This project is something I have personally wanted to do since my sophomore year. My work as a systems administrator and interest in Linux systems brought me into frequent contact with Unix shells, and as I became more proficient with them, I wanted to better understand how they worked.

	\section{Objective}
    The objective of this project is to implement a command-line shell for Unix systems. Ideally, the shell should be able to take a command as input, parse it for relevant syntactic elements, execute it, and return the output. The shell should possess similar features and syntax to the Bourne-again shell \verb|bash|.
    
	\section{Outline}
	Chapter \ref{background} discusses much of the background needed to understand this project. Chapter \ref{development} is about the actual development and implementation of the shell, including how each of the shell's features works and what limitations were encountered during development. Chapter \ref{discussion} discusses the outcome of the shell, takeaways from this project, and possible future improvements.

	\chapter{Background} \label{background}

	\section{Shells} \label{sec:shells}
	A shell refers to any program that allows a user to interact with a computer's operating system. In general usage, the term refers to a command-line shell (or command-line interpreter). These programs provide an interface for the user to input commands following a specific syntax, then parse and evaluate the output. (This is known as a read-eval-print loop, or REPL.) Many also offer the ability to read commands from a script and features like redirection and pipelines.

	\subsection{Unix Shells} \label{sec:unix-shells}
	The first shell for Unix was developed by Ken Thompson in 1971. It operated as a standalone user program and achieved a compact size by keeping functions in separate programs, such as \verb|glob| (which handled parameter expansion) and \verb|if| statements. The Thompson shell is notable for introducing the file redirection syntax that is ubiquitous among Unix shells today, using symbols like \verb|<|, \verb|>|, and \verb|>>| to pipe command output into files. Another major development came in 1977, when Stephen Bourne created the shell that bears his name. The Bourne shell added scripting capabilities to traditional interactive functions, with more advanced control structures, as well as features such as command substitution. The Bourne shell serves as the ancestor of many modern Unix shells, including \verb|bash|, the Bourne-again shell, which is the default on many Unix-based operating systems. Other notable shells include the C shell \verb|csh|, the Korn shell \verb|ksh|, and the Z shell \verb|zsh|, which all include additional features and syntax variations. Unix shells have traditionally been written in the C programming language, which was originally developed to be the language of choice for Unix.\cite{shells}
	
	\subsection{Shells for Other Systems} \label{sec:shells-for-other-systems}
	There are many shells that are not designed for Unix systems. The best-known of these programs is the Windows Command Processor, sometimes referred to by its file name \verb|cmd.exe|. \verb|cmd.exe| comes standard with all installations of Windows and is inspired by DOS command prompts. Microsoft has also created PowerShell, which introduces a paradigm involving commands called “cmdlets” that perform operations along with “providers”, which provide the cmdlets access to data stores.\cite{powershell} PowerShell is available for Windows, macOS, and Linux operating systems.

	\section{Unix} \label{sec:unix}
	Unix in the context of this project refers to a family of operating systems derived from and inspired by the Unix operating system. Unix was originally written in 1969 at AT\&T Bell Labs by Ken Thompson, Dennis Ritchie, and their collaborators for the DEC PDP-7 minicomputer.\cite{unix} Its derivatives include the BSD family of operating systems and Apple's macOS operating system. Unix-inspired operating systems include the Linux family of operating systems. The Unix family of operating systems share what is known as the “Unix philosophy”, a core set of tenets that underpin the ideals of Unix design. The Unix philosophy emphasizes simplicity and specialization for software.\cite{philosophy} In addition, many standards have been set forth for ensuring consistency and compatibility between Unix-family operating systems, including the Portable Operating System Interface (POSIX), the Single Unix Specification, and the Linux Standards Base (LSB).\cite{standards}

	\subsection{BSD} \label{sec:bsd}
	BSD refers both to the original Berkeley Software Distribution (BSD), released in 1978 by the University of California, Berkeley, and its derivatives. BSD was derived from the source code of Bell Labs Unix, and over time gained improvements including \verb|ex|, a new version of the Unix editor \verb|ed|, and the C shell \verb|csh|.\cite{bsd-csrg} BSD's most notable accomplishment is rewriting much of the operating system to remove AT\&T's code, which was under a restrictive license.\cite{berkeley-unix} This allowed for the open-sourcing of BSD and other Unix-based operating systems. BSD's derivatives include FreeBSD, NetBSD, and OpenBSD.

	\subsection{Linux} \label{sec:linux}
	Linux can refer to the Linux operating system, written by Linus Torvalds in 1991, or more commonly to the family of operating systems derived from the original Linux and using the Linux kernel. Linux was originally written by Torvalds for the x86 platform as an experiment regarding the features available to such CPUs, and as such was confined to that platform during its first years of development. The first successful port of Linux to a different CPU architecture was to the Motorola 680x0 family, and since then Linux has become famous for its portability, with Linux ports available for most major architectures. The Linux kernel is a monolithic system (in contrast to microkernels, which are made up of smaller kernels that work in harmony), and Linux's main goals include simplicity, efficiency, and compatibility.\cite{linux} Linux is Unix-inspired; it is not derived directly from the original Unix or a derivative, but aims to follow Unix standards and provide all the relevant Unix behavior expected of it by its users.

	\section{Rust} \label{sec:rust}
	Rust is a programming language for “developing reliable and efficient systems”. It is intended for systems programming and aims to give users “control over the running time and memory usage of their programs” while still offering memory safety by eschewing such traditional features as a garbage collector (which aims to recover no-longer-referenced memory) in favor of a system of ownership. The ownership system provides a framework for passing objects and references to objects to various owners in the program, so that referenced objects can be deallocated when their owner is.\cite{rust}

	\chapter{Development} \label{development}
	
	\section{Criteria} \label{sec:criteria}
	This shell should ideally be able to do the following:
	
	\begin{itemize}[noitemsep,topsep=0pt]
	    \item Execute commands
	    \item Get input from user prompt
	    \item Move cursor back and forth with arrow keys
	    \item Parse shell syntax, including special characters
	    \item Store shell history to file
	    \item Allow selection and execution of prior commands with arrow keys
	    \item Redirect output to file
	    \item Pipe output to another command
	    \item Run commands from a script
	    \item Set environment variables
	\end{itemize}
	
	\section{Programming Environment} \label{sec:programming-environment}
	This shell was written in version 1.55 of the Rust programming language, with the \verb|rustc| compiler. The \verb|cargo| package manager was used to handle dependencies for the project. Coding was primarily done in the CLion IDE on Fedora Linux.
	
	The following packages were used in this project:
	\begin{itemize}[noitemsep,topsep=0pt]
		\item \verb|home|, version 0.5.3
		\item \verb|hostname|, version 0.3.1
		\item \verb|is_executable|, version 1.0.1
		\item \verb|regex|, version 1.5.4
		\item \verb|termion|, version 1.5.6
		\item \verb|users|, version 0.11.0
	\end{itemize}

	\section{Implementation} \label{sec:implementation}

	\subsection{Command Execution} \label{sec:command-execution}
	Shells have traditionally been written in C, and often make use of C's \verb|fork| system call to execute commands. Rust simplifies this process for us with the \verb|std::process::Command| struct, which provides an interface to run commands and handle their outputs.

	The following code block handles non-builtin commands and returns their exit codes, returning a code of 127 if there is an error.

	\lstset{style=boxed}
	\begin{lstlisting}[language=Rust,caption={General code to execute commands}]
let child = Command::new(command).args(args).spawn();
match child {
    Ok(mut x) => {
        x.wait().unwrap().code().unwrap()
    }
    Err(_) => 127,
}\end{lstlisting}

	Builtins, as their name suggests, are programmed into the shell itself. These include \verb|cd|, which changes the current directory; \verb|history|, which displays previously used commands; \verb|!!|, which runs the last command; and \verb|exit|, which exits the shell.
	
	\subsection{Path Handling} \label{sec:path-handling}
	There is special code used to handle filesystem paths. Paths include some conventions designed to reduce typing, such as \verb|~| (the user's home directory, usually \verb|/home/user|) and \verb|..| (the parent of the current working directory, e.g. \verb|/home/user| for \verb|/home/user/Documents|). In order to convert these paths into actual filesystem locations, the function \verb|canonical_path| was written as follows:
	
	\begin{lstlisting}[language=Rust, caption={Code to canonicalize paths},breaklines=true]
pub fn canonical_path(x: &&str) -> String {
    let homedir = home::home_dir().unwrap().display().to_string();
    let mut canon = String::from(*x);
    if x.starts_with(&"~") {
        canon = canon.replace("~", &homedir);
    } else if x.contains(&"..") {
        let mut spl = x.split("..").peekable();
        let mut np = Vec::new();
        while let Some(y) = spl.next() {
            let p = match spl.peek() {
                Some(_) => dotdot(PathBuf::from(y)),
                None => String::from(y),
            };
            np.push(p);
        }
        canon = np.join("/");
    }
    canon
}\end{lstlisting}
	
	The \verb|dotdot| function gets the parent of a directory:
	
	\begin{lstlisting}[language=Rust,caption={Code to get parent of directory}]
fn dotdot(mut buf: PathBuf) -> String {
    buf.pop();
    return buf.display().to_string();
}\end{lstlisting}

	\subsection{Command History} \label{sec:command-history}
	After each command is executed, information about it is stored in a file located at \verb|~/.shell_history|. A line in the history file looks like the following:
	
	\begin{lstlisting}[caption={Example line in a shell history file}]
: 1647353057:0;ls\end{lstlisting}

	The first number is the Unix time representation for when the command was executed. In the example, the command was run at Unix time 1647353057, which is 10:04:17 AM EDT on March 15, 2022. The second number (after the colon) represents how long the command took, in seconds, to complete. In this case, the command took under a second to run, so it is noted as taking zero seconds. The final part of the line is the command itself, which is written after the semicolon. \verb|ls| is the standard utility to list the contents of a directory on Unix-based systems. This format was taken from the history file of \verb|zsh|, with one difference: this shell writes the time to run as the difference between when the command was completed and when it was called, which is not the default behavior on \verb|zsh| (though it is available through an option).
	
	When a new instance of the shell is started, a function called \verb|read_history| opens the history file and reads all the lines into a new vector. As commands are executed, the shell appends them to both the vector and the file. This enables the user to search through their past commands using the up and down arrow keys and execute them again. Whenever an arrow key is pressed, a variable corresponding to an index in the history vector is incremented or decremented by one, and the contents of the vector at that index are written to the screen.
	
	\subsection{Script Execution} \label{sec:script-execution}
	A simple form of script execution was implemented in this shell. When a command is entered, the shell first checks to see if the command is actually the name of a file. If it is, the next check is to see if the file is executable (it has the executable bit set). If the file is not executable, the command returns a ``not executable" error and an error code of 126.
	
	If the file is executable, the shell opens the file and executes commands line-by-line. Future plans include supporting shebangs (e.g. \verb|#!/bin/bash|), which specify which shell to run a script with, to ensure proper syntactic support.

	\subsection{Interface} \label{sec:interface}
	The \verb|termion| library makes it possible to interact with the terminal emulator that the shell runs in.
	
	Here are some notable keys and key combinations:
	
	\begin{itemize}[noitemsep,topsep=0pt]
	    \item Enter: Submit typed line to be executed
	    \item Up: Switch to an earlier command
	    \item Down: Switch to a more recent command
	    \item Left: Move cursor one position to the left
	    \item Right: Move cursor one position to the right
	    \item Ctrl+C: Break typing, start new line
	    \item Ctrl+D: Exit shell
	    \item Ctrl+L: Clear screen
	\end{itemize}

	\section{Testing} \label{sec:testing}
	Testing was primarily conducted on the development machine, using the \verb|gnome-terminal| terminal emulator on Fedora Linux. In testing, this program successfully took user input and executed a corresponding command. It was able to change directories correctly and load command history. The shell responded to key events, including Ctrl+C, Ctrl+D, and Ctrl+L, with the appropriate actions, and was able to load past commands into the prompt using arrow keys.

	\section{Limitations} \label{sec:limitations}
	While significant progress has been made on this shell, it is not without its fair share of limitations.
	
    \begin{itemize}[noitemsep,topsep=0pt]
        \item The syntax parser is currently highly simplistic and only splits on spaces. A full-featured shell syntax parser needs to correctly handle characters like \verb|'|, \verb|"|, \verb|$|, \verb|(|, \verb|)|, \verb|\|, \verb=|=, \verb|>|, \verb|`|, and \verb|&|, all of which have different meanings, making it complex to design.
        \item As of right now, the shell can only output to \verb|/dev/stdout| and \verb|/dev/stderr|. Pipes and redirects to files are still unsupported, as they depend on an intelligent syntax parser and need extra configuration for the command-execution code to set a different output.
        \item There is a bug that causes inconsistent and incorrect behavior when running programs with interactive input. Running \verb|python| from within the shell causes the majority of characters to be stored by the shell instead of being passed to Python. Meanwhile, running another shell like \verb|bash| or \verb|zsh| inside this shell causes this shell's process to be suspended as soon as typing begins. Non-interactive commands are recommended for best results.
    \end{itemize}

	\subsection{Interface Character Processing} \label{sec:interface-character-processing}
	One specific bug in the code resulted in months of debugging. When starting the shell for the first time, the first command would be read properly, but whenever inputting every following command, the first character would never be captured.
	
	The problem seems to have arisen from a choice in the structure of the program. \verb|main.rs|, the file that handles reading input and calling execution methods (which are located in another file), had a \verb|main| method, which served as a high-level manager of other sections of code, and a \verb|read| method, which actually read the input and returned the command to \verb|main| so that it could be executed.
	
	Whenever the command was returned to \verb|main|, the program stopped capturing input from \verb|stdin| until a character was entered, meaning that character would be dropped. The exact mechanics causing this issue are unclear, but it resulted in a refactor of \verb|main.rs| where \verb|read| was incorporated into \verb|main|. While this is not ideal from a programming structure perspective, as it makes \verb|main| unwieldy, all characters are now read properly.

	\chapter{Discussion} \label{discussion}
	Overall, this shell was a partial success. It accomplished much of its core functionality by being able to execute commands, and also offered some features like keyboard shortcuts and command history. However, more complex manipulation of commands (redirects, pipes, etc.) could not be implemented in time.
	
	This shell is usable in limited cases. If running simple, non-interactive commands (e.g. \verb|ls|, \verb|cd|, \verb|whoami|), this shell will work as intended. However, interactive commands have issues and advanced syntax still has not been implemented, meaning the shell will fail with more complex commands.
	
	\section{Takeaways} \label{sec:takeaways}
	This project reminded me that parts of a task are not necessarily as hard or easy as they might seem. For example, I suspected coming into this project that executing commands would be difficult based on how C used \verb|fork|, but that turned out to be comparatively simple thanks to \verb|std::process::Command|. On the other hand, writing a parser ended up being quite difficult because of how much there was to match and extract, and work on that is still far from complete.
	
    This project was also quite useful for learning about Rust. Working on this shell brought me in contact with a number of Rust's features (such as \verb|match| statements, which I used extensively in this shell for functionality like reading input and executing commands) as well as its quirks (for example, writing to \verb|stdout| using \verb|write!| produces an \verb|Result|, which represents either an \verb|Ok| or an \verb|Error| depending on the write's success and needs to be handled with the \verb|unwrap| function).
	
	\section{Future Improvements} \label{sec:future-improvements}
	Here are some potential improvements for this shell:
	
	\begin{itemize}[noitemsep,topsep=0pt]
	    \item Build a complete shell syntax parser. This is required for many of the other improvements, which depend on specific shell syntax (e.g. \verb|>|, \verb|$(...)|).
	    \item Configure piping commands into other commands (e.g. \verb`ls | grep Music`, which lists the contents of the current working directory and searches the list for files named Music). This will likely require some work with \verb|std::process::Command| and its options.
	    \item Add the ability to redirect command output into files. This will likely require some work with \verb|std::process:Command| and its options.
	    \item Fix the issue involving interactive programs mentioned in section \ref{sec:limitations}.
	\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Appendices
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\appendix


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\bibliographystyle{acm}

	\bibliography{references}


\end{document}