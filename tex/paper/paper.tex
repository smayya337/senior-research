%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Packages are included below, these are akin to libraries in other programming languages. As far as I can tell, there is no reason to reduce the number of packages included in a document. It might compile faster, but overleaf compiles fast so this should not be an issue.
\documentclass[12pt,twoside]{report} %tells the compiler that this is a 'report' style document, and the main font size.
\usepackage{setspace} %allows the use of '\doublespace' to set line spacing
\usepackage[utf8]{inputenc} %inclusion of this is optional, overleaf includes it in its compiler so it is not necessary, it may be necessary for other compilers.
\usepackage[english]{babel} %this does a few things eg allowing dates to be made by the compiler. probably best not to get rid of it
\usepackage{wrapfig} %if it is desirable to wrap text (see https://www.overleaf.com/learn/latex/Wrapping_text_around_figures).
\usepackage{graphicx} %this allows graphics to be put in easily
\usepackage{float}%this allows you to put them in good places
\usepackage[version=4]{mhchem} %this is good for chemical reactions
\usepackage{amsmath} %maths package
\usepackage{amssymb} %symbol package
\usepackage{textcomp,gensymb} %more symbols (eg \degree)
\usepackage{appendix} %self explanatory
\usepackage{colortbl} %good for colouring in cells on a table
\usepackage{rotating} %allows you to rotate graphics
\usepackage{bm} %helps bold things
\usepackage{multirow} %for tables
\usepackage{longtable} %for long tables
\usepackage{booktabs} %more tables
\usepackage{pdfpages} %allows PDFs to be included in document (good if you want to include a pdf in an appendix eg)
\usepackage{caption} %allows captions for graphics
\usepackage[nottoc]{tocbibind} %adds the bibliography to the table of contents
\usepackage{subcaption} %allows subcaption for multiple images in one graphic
\usepackage{enumitem} %for the bulleted lists

\PassOptionsToPackage{hyphens}{url}
\usepackage{hyperref} %this is great for putting hyperreferences in the document.
\usepackage[table]{xcolor} %more colouring of tables
\definecolor{Gray}{gray}{0.9} %this defines a colour to be used and gives it a name. This is a colour called 'Gray' it is 'gray' with transparency 0.9
\input{rust.tex}  %I used this to format rust code well in my report. I'm sure there are other packages/methods for other languages.
\hypersetup{colorlinks=false} %this stops links being colourful, which makes a report look less professional I believe.


\usepackage[letterpaper, top=1in, bottom = 1in, right = 1in, left=1in]{geometry} %this describes the layout of the document and the margins etc.
\doublespacing %self explanatory
\usepackage{afterpage} %for blank pages

\title{Implementing a Unix Shell}
\author{Shreyas Mayya}
\date{April 29, 2022}

\begin{document} % you have to do this to start the document

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%For a long report such as a thesis, I would recommend thinking like programming, that is, have a short 'main' and long programs (or chapters in this case) this allows you to access each chapter easily and see the layout of the document easily.
%
%using \input{} basically puts the code specified in the argument (between the braces) into the body of the code in main
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The entire thesis is generated by the commands below, referencing the other files in this directory.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Preamble
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\begin{titlepage}
		\begin{center}
			\vspace*{1.75in}
			\Huge
			\textbf{Implementing a Unix Shell}
			\vspace{0.5in}

			\LARGE
			\textbf{Shreyas Mayya}
			\vspace{0.5in}

			\Large
			Computer Systems Lab\\
			Thomas Jefferson High School for Science and Technology\\
			Alexandria, VA\\
			April 29, 2022
		\end{center}
	\end{titlepage}

	\pagenumbering{roman} %Roman numbering is recommended until the body

	\newcommand\blankpage{%
		\null
		\thispagestyle{empty}%
		\addtocounter{page}{-1}%
		\newpage}

	\afterpage{\blankpage{}}

	\chapter*{Acknowledgments}
	I would like to thank:
	
	\afterpage{\blankpage{}}

	\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Chapters
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	\chapter*{Abstract}
	

	\afterpage{\blankpage{}}

	\chapter{Introduction}
	
	\pagenumbering{arabic} %back to Arabic numbering for the rest

	\section{Objective}

	\section{Outline}
	Chapter \ref{background} discusses much of the background needed to understand this project. Chapter \ref{development} is about the actual development and implementation of the shell.

	\chapter{Background} \label{background}

	\section{Shells} \label{sec:shells}
	A shell refers to any program that allows a user to interact with a computer's operating system. In general usage, the term refers to a command-line shell (or command-line interpreter). These programs provide an interface for the user to input commands following a specific syntax, then parse and evaluate the output. (This is known as a read-eval-print loop, or REPL.) Many also offer the ability to read commands from a script and features like redirection and pipelines.

	\subsection{Unix Shells} \label{sec:unix-shells}
	The first shell for Unix was developed by Ken Thompson in 1971. It operated as a standalone user program and achieved a compact size by keeping functions in separate programs, such as \verb|glob| (which handled parameter expansion) and \verb|if| statements. The Thompson shell is notable for introducing the file redirection syntax that is ubiquitous among Unix shells today, using symbols like \verb|<|, \verb|>|, and \verb|>>| to pipe command output into files. Another major development came in 1977, when Stephen Bourne created the shell that bears his name. The Bourne shell added scripting capabilities to traditional interactive functions, with more advanced control structures, as well as features such as command substitution. The Bourne shell serves as the ancestor of many modern Unix shells, including \verb|bash|, the Bourne-again shell, which is the default on many Unix-based operating systems. Other notable shells include the C shell \verb|csh|, the Korn shell \verb|ksh|, and the Z shell \verb|zsh|, which all include additional features and syntax variations. Unix shells have traditionally been written in the C programming language, which was originally developed to be the language of choice for Unix.

	\section{Unix} \label{sec:unix}
	Unix in the context of this project refers to a family of operating systems derived from and inspired by the Unix operating system. Unix was originally written in 1969 at AT\&T Bell Labs by Ken Thompson, Dennis Ritchie, and their collaborators for the DEC PDP-7 minicomputer. Its derivatives include the BSD family of operating systems. Unix-inspired operating systems include the Linux family of operating systems.

	\subsection{BSD} \label{sec:bsd}
	BSD refers both to the original Berkeley Software Distribution (BSD), released in 1978 by the University of California, Berkeley, and its derivatives. BSD was derived from the source code of Bell Labs Unix, and over time gained improvements including \verb|ex|, a new version of the Unix editor \verb|ed|, and the C shell \verb|csh|. BSD's most notable accomplishment was rewriting much of the operating system to remove AT\&T's code, which was under a restrictive license. This allowed for the open-sourcing of BSD and other Unix-based operating systems. BSD's derivatives include FreeBSD, NetBSD, OpenBSD, and DragonFlyBSD.

	\subsection{Linux} \label{sec:linux}
	Linux can refer to the Linux operating system, written by Linus Torvalds in 1991, or more commonly to the family of operating systems derived from the original Linux and using the Linux kernel. Linux was originally written by Torvalds for the x86 platform as an experiment regarding the features available to such CPUs, and as such was confined to that platform during its first years of development. The first successful port of Linux to a different CPU architecture was to the Motorola 680x0 family, and since then Linux has become famous for its portability, with Linux ports available for most major architectures. The Linux kernel is a monolithic system (in contrast to microkernels, which are made up of smaller kernels that work in harmony), and Linux's main goals include simplicity, efficiency, and compatibility.\cite{linux} Linux is Unix-inspired; it is not derived directly from the original Unix or a derivative, but aims to follow Unix standards and provide all the relevant Unix behavior expected of it by its users.

	\section{Rust} \label{sec:rust}
	Rust is a programming language for "developing reliable and efficient systems". It is intended for systems programming and aims to give users "control over the running time and memory usage of their programs" while still offering memory safety by eschewing such traditional features as a garbage collector (which aims to recover no-longer-referenced memory) in favor of a system of ownership. The ownership system provides a framework for passing objects and references to objects to various owners in the program, so that referenced objects can be deallocated when their owner is.\cite{rust}

	\chapter{Development} \label{development}
	
	\section{Criteria} \label{sec:criteria}
	
	\section{Programming Environment} \label{sec:programming-environment}
	This shell was written in version 1.55 of the Rust programming language, with the \verb|rustc| compiler. The \verb|cargo| package manager was used to handle dependencies for the project. Coding was primarily done in the CLion IDE on Fedora Linux.
	
	The following packages were used in this project:
	\begin{itemize}[noitemsep,topsep=0pt]
		\item \verb|home|, version 0.5.3
		\item \verb|hostname|, version 0.3.1
		\item \verb|is_executable|, version 1.0.1
		\item \verb|regex|, version 1.5.4
		\item \verb|termion|, version 1.5.6
		\item \verb|users|, version 0.11.0
	\end{itemize}

	\section{Implementation} \label{sec:implementation}

	\subsection{Command Execution} \label{sec:command-execution}
	Shells have traditionally been written in C, and often make use of C's \verb|fork| system call to execute commands. Rust simplifies this process for us with the \verb|std::process::Command| struct, which provides an interface to run commands and handle their outputs.

	The following code block handles non-builtin commands and returns their exit codes, returning a code of 127 if there is an error.

	\lstset{style=boxed}
	\begin{lstlisting}[language=Rust]
let child = Command::new(command).args(args).spawn();
match child {
    Ok(x) => {
        let mut y = x;
        y.wait().unwrap().code().unwrap()
    }
    Err(_) => 127,
}\end{lstlisting}

	Builtins, as their name suggests, are programmed into the shell itself. These include \verb|cd|, which changes the current directory; \verb|history|, which displays previously used commands; and \verb|exit|, which exits the shell.

	\subsection{Command History} \label{sec:command-history}
	After each command is executed, information about it is stored in a file located at \verb|~/.shell_history|. (\verb|~| is a convention referring to the user's home directory, usually \verb|/home/user|.) A line in the history file looks like the following:
	
	\begin{lstlisting}
: 1647353057:0;ls\end{lstlisting}

	The first number is the Unix time representation for when the command was executed. In the example, the command was run at Unix time 1647353057, which is 10:04:17 AM EDT on March 15, 2022. The second number (after the colon) represents how long the command took, in seconds, to complete. In this case, the command took under a second to run, so it is noted as taking zero seconds. The final part of the line is the command itself, which is written after the semicolon. \verb|ls| is the standard utility to list the contents of a directory on Unix-based systems. This format was taken from the history file of \verb|zsh|, with one difference: this shell writes the time to run as the difference between when the command was completed and when it was called, which is not the default behavior on \verb|zsh| (though it is available through an option).
	
	When a new instance of the shell is started, a function called \verb|read_history| opens the history file and reads all the lines into a new vector. As commands are executed, the shell appends them to both the vector and the file. This enables the user to search through their past commands using the up and down arrow keys and execute them again. Whenever an arrow key is pressed, a variable corresponding to an index in the history vector is incremented or decremented by one, and the contents of the vector at that index are written to the screen.
	
	\subsection{Script Execution} \label{sec:script-execution}

	\subsection{Interface} \label{sec:interface}
	

	\section{Testing} \label{sec:testing}
	Testing was primarily conducted on the development machine, using the \verb|gnome-terminal| terminal emulator on Fedora Linux. In testing, this program successfully took user input and executed a corresponding command. It was able to change directories correctly and load command history. The shell responded to key events, including Ctrl+C, Ctrl+D, and Ctrl+L, with the appropriate actions, and was able to load past commands into the prompt using arrow keys.

	\section{Limitations} \label{sec:limitations}

	\subsection{Interface Character Processing} \label{sec:interface-character-processing}

	\chapter{Discussion} \label{discussion}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Appendices
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\appendix


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Bibliography
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	\bibliographystyle{acm}

	\bibliography{references}


\end{document}